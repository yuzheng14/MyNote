# IoC容器及底层原理

## IOC的概念和原理

### 什么是IoC

控制反转（Inversion of Control），把对象创建和对象之间的调用过程，交给Spring进行管理

使用IoC的目的是为了降低耦合度

入门案例就是IoC的实现

### IoC的底层原理

#### 使用到的技术

xml解析、工厂模式、反射

#### 演变过程

##### 原始方式

有两个类`UserService`和`UserDao`

```java
class UserDao{
    add(){
        ......
    }
}
```

```java
class UserService{
    execute(){
        UserDao dao =new UserDao();
        dao.add();
    }
}
```

其中`UserServise`类要调用`UserDao`类中的方法，要实例化`UserDao`再进行调用，耦合度高

##### 使用工厂模式

创建三个类

```java
class UserDao{
    add(){
        ......
    }
}
```

```java
class UserFactory{
    public static UserDao getUserDao(){
        return new UserDao();
    }
}
```

```java
class UserService{
    execute(){
        UserDao dao = UserFactory.getUserDao();
        dao.add();
    }
}
```

通过`UserFactory`工厂获得`UserDao`类，降低了耦合度。但是虽然`UserDao`和`UserService`解耦，但是工厂还是有耦合度

最终目的是将耦合度降至最低限度

#### IoC过程

进一步降低了耦合度

##### 第一步	XML配置文件，配置创建对象

```xml
<bean id="dao" class="com.yuzheng14.springlearning.UserDao"></bean>
```

##### 第二步	有Service类和Dao类，创建工厂类

```java
class UserFactory{
    public static UserDao getUserDao(){
        String classValue="......";
        Class clazz = Class.forName(classValue);
        return (UserDao)clazz.newInstance();
    }
}
```

###### 通过xml解析获取到类的全限定名称

```java
String classValue="......";
```

###### 反射获取到类

```java
Class clazz = Class.forName(classValue);
```

###### 实例化对象

```java
clazz.newInstance();
```

## IoC接口

IoC思想基于IoC容器完成，IoC容器底层就是对象工厂

### Spring提供IoC容器的两种实现方式（两个接口）

#### BeanFactory

IoC容器的基本实现，是Spring内部使用的接口，不提供给开发人员使用

> 加载配置文件的时候不会创建对象，在获取（使用）对象时才去创建对象

```java
User user = context.getBean("user");	//此时进行对象创建
```



#### ApplicationContext

BeanFactory接口的子接口，提供了更多更强大的功能，一般面向开发人员使用

> 加载配置文件时就进行创建对象

```java
ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");	//此时就进行对象创建
```

##### ApplicationContext接口的实现类

![类图关系加载失败](http://www.plantuml.com/plantuml/png/dP6n2eD038Pt7yOdwA08TMcXrANhUOtruCn94ak5FdnrSEePE3V9d--B_5Um699fy5avZjvP8ovW5L3W8wTldY-VdNjDP5eF_nkP7g-2icKXOoK2xqShM0C2EPlCRUaTEWBkTtvyiskd7zTBAjd8Ch47xzKKmdjEXKl48DjmUOm8hrUYTwTBzTsOEbwgcgxusNbePXOO3WegRvXlHleuNm0-fy7_0000)

(头一次使用UML不太熟悉将就着看叭)

## IoC操作Bean管理

### Bean管理是什么？

Bean管理指的是两个操作：Spring创建对象、Spring注入属性

### Bean管理操作

#### 基于xml配置文件方式实现

##### 创建对象

```xml
<bean id="user" class="com.yuzheng14.springlearning.User"></bean>
```

- 使用`<bean>`标签实现对象创建

- `<bean>`中属性介绍

  > id：唯一标识
  >
  > class：类的全限定类名

- 创建对象时，默认执行无参构造方法

##### 注入属性

DI：依赖注入

###### 使用setter方式注入

**创建类，使用setter注入属性**

```java
package com.yuzheng14.springlearning;

public class Book {
    private String name;
    private String author;

    public void setName(String name) {
        this.name = name;
    }

    public void setAuthor(String author) {
        this.author = author;
    }
}
```

**Spring配置对象创建后配置属性注入**

```xml
<bean id="book" class="com.yuzheng14.springlearning.Book">
	<property name="name" value="Head First Java"/>
	<property name="author" value="Kathy Sierra,Bert Bates"/>
</bean>
```

- 在bean标签内使用`<property>`标签实现属性注入

- `<property>`中属性介绍

  > name：类中属性的名称
  >
  > value：要注入的值

- 调用setter注入属性

###### 使用有参构造方式注入

**创建类，定义属性，创建属性对应有参构造方法**

```java
package com.yuzheng14.springlearning;

public class Order {
    private String name;
    private String address;

    public Order(String name,String address){
        this.address=address;
        this.name=name;
    }
}
```

**在Spring配置文件中进行配置**

```xml
<bean id="order" class="com.yuzheng14.springlearning.Order">
	<constructor-arg name="name" value="computer"/>
	<constructor-arg name="address" value="China"/>
</bean>
```

- 在bean标签内使用`<constructor-arg>`标签实现属性注入

- `<constructor-arg>`中属性介绍

  > name：构造器参数的名称
  >
  > index：构造器参数的顺序（和name二选一）（基数为0）
  >
  > value：要注入的值

- 调用setter注入属性

###### p名称空间注入（了解）

使用p名称空间，可以简化基于xml配置方式

**第一步  在配置文件的`<beans>`中添加p名称空间**

修改后的`<beans>`

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
</beans>
```

**第二步  在`<bean>`标签里添加属性，进行属性注入**

```xml
<bean id="book" class="com.yuzheng14.springlearning.Book" p:name="Head First Java" p:author="Kathy Sierra,Bert Bates"></bean>
```

##### xml注入其他类型属性

###### 字面量

- null值

  ```xml
  <bean id="book" class="com.yuzheng14.springlearning.Book">
  	<property name="name" value="Head First Java"/>
  	<property name="author" value="Kathy Sierra,Bert Bates"/>
  	<property name="address">
  		<null/>
  	</property>
  </bean>
  ```

  

- 属性值包含特殊符号

  - 把<>转义

    ```xml
    <property name="address" value="&lt;&lt;南京&gt;&gt"></property>
    ```

    | 符号 | 字段    | 释义         | 说明   |
    | ---- | ------- | ------------ | ------ |
    | \<   | \&lt;   | less than    | 小于号 |
    | \>   | \&gt;   | greater than | 大于号 |
    | \&   | \&amp   |              | 和     |
    | \'   | \&apos; |              | 单引号 |
    | \"   | \&quot; |              | 双引号 |

  - CDATA

    ```xml
    <property name="address">
        <value><![CDATA[<<南京>>]]></value>
    </property>
    ```

##### 注入外部Bean

###### 创建service类和dao类

```java
package com.yuzheng14.springlearning.service;
public class UserService {
    public void add(){
        System.out.println("service add......");
    }
}
```

```java
package com.yuzheng14.springlearning.dao;
public interface UserDao {
    public void update();
}
```

```java
package com.yuzheng14.springlearning.dao;
public class UserDaoImpl implements UserDao {
    @Override
    public void update() {
        System.out.println("dao update..........");
    }
}
```

###### 在service调用dao里面的方法

```java
package com.yuzheng14.springlearning.service;
import com.yuzheng14.springlearning.dao.UserDao;
import com.yuzheng14.springlearning.dao.UserDaoImpl;
public class UserService {
    public void add(){
        System.out.println("service add......");
        UserDao userDao=new UserDaoImpl();
        userDao.update();
    }
}
```

###### 在Spring配置文件中进行配置

##### 注入内部bean和级联赋值

#### 基于注解方式实现



### 基于xml

### 基于注解

