# DQL语言

## 基础查询

### 语法

```mysql
SELECT 查询列表 FROM 表名;
```

### 特点

- 查询列表可以是表中的字段、常量值、表达式、函数
- 查询的结果是一个虚拟的表格

### 查询

#### 查询单个字段

```mysql
SELECT 字段 FROM 表名;
```

#### 查询多个字段

```mysql
SELECT 字段，字段... FROM 表名;
```

#### 查询表中所有字段

```mysql
SELECT * FROM 表名;
```

字段名可用着重号`包裹以区分

#### 查询常量值

```mysql
SELECT 100;
SELECT 'john';
```

```
+-----+
| 100 |
+-----+
| 100 |
+-----+
1 row in set (0.00 sec)
```

#### 查询表达式

```mysql
SELECT 100*98;
```

```
+--------+
| 100*98 |
+--------+
|   9800 |
+--------+
1 row in set (0.00 sec)
```

#### 查询函数

```mysql
SELECT VERSION();
```

```
+-----------+
| VERSION() |
+-----------+
| 8.0.20    |
+-----------+
1 row in set (0.00 sec)
```

### 起别名

#### AS关键字

```mysql
SELECT 98*100 AS 结果;
```

```
+------+
| 结果 |
+------+
| 9800 |
+------+
1 row in set (0.00 sec)
```

```mysql
SELECT last_name AS 姓, first_name AS 名 FROM employees;
```

```
+-------------+-------------+
| 姓          | 名          |
+-------------+-------------+
| K_ing       | Steven      |
| Kochhar     | Neena       |
| De Haan     | Lex         |
		   ......
| Errazuriz   | Alberto     |
| Higgins     | Shelley     |
| Gietz       | William     |
+-------------+-------------+
107 rows in set (0.00 sec)
```

#### 直接写别名

```mysql
SELECT last_name 姓, first_name 名 FROM employees;
```

```
+-------------+-------------+
| 姓          | 名          |
+-------------+-------------+
| K_ing       | Steven      |
| Kochhar     | Neena       |
| De Haan     | Lex         |
		   ......
| Errazuriz   | Alberto     |
| Higgins     | Shelley     |
| Gietz       | William     |
+-------------+-------------+
107 rows in set (0.00 sec)
```

#### 好处

- 便于理解
- 有重复字段的情况时可以及进行区分

### 去重

使用DISTINCT关键字

```mysql
SELECT DISTINCT department_id FROM employees;
```

```
+---------------+
| department_id |
+---------------+
|          NULL |
|            10 |
|            20 |
|            30 |
|            40 |
|            50 |
|            60 |
|            70 |
|            80 |
|            90 |
|           100 |
|           110 |
+---------------+
12 rows in set (0.00 sec)
```

### +号的作用

SQL中的+号只有运算符的作用

#### 两方都为数值类型

数值加法

```mysql
SELECT 100+98;
```

```
+--------+
| 100+98 |
+--------+
|    198 |
+--------+
1 row in set (0.00 sec)
```

#### 一方为字符型

尝试将字符型转换为数值型，转换成功则数值加法，失败则字符型转换为0

```mysql
SELECT '100'+98;
```

```
+----------+
| '100'+98 |
+----------+
|      198 |
+----------+
1 row in set (0.00 sec)
```

```mysql
SELECT 'john'+98;
```

```
+-----------+
| 'john'+98 |
+-----------+
|        98 |
+-----------+
1 row in set, 1 warning (0.00 sec)
```

#### 一方为null

### 拼接字符串

`concat(str1,str2,...)`函数

```mysql
SELECT CONCAT(first_name,'-',last_name) AS 姓名 FROM employees;
```

```
+-------------------+
| 姓名              |
+-------------------+
| Steven-K_ing      |
| Neena-Kochhar     |
| Lex-De Haan       |
		......
| Shelley-Higgins   |
| William-Gietz     |
+-------------------+
107 rows in set (0.00 sec)
```

若有null数据则返回null（同+号）

```mysql
SELECT CONCAT(commission_pct,",",employee_id) AS 结果 FROM employees;
```

```
+----------+
| 结果     |
+----------+
| NULL     |
| NULL     |
	......
| 0.25,161 |
| 0.25,162 |
| 0.15,163 |
| 0.10,164 |
| 0.10,165 |
	......
| NULL     |
| NULL     |
+----------+
107 rows in set (0.00 sec)
```

此时可使用`IFNULL(exper1,exper2)`函数

```mysql
SELECT CONCAT(IFNULL(commission_pct,0),",",employee_id) AS 结果 FROM employees;
```

```
+----------+
| 结果     |
+----------+
| 0.00,100 |
| 0.00,101 |
| 0.00,102 |
	......
| 0.30,148 |
| 0.20,149 |
| 0.30,150 |
| 0.25,151 |
	......
| 0.00,203 |
| 0.00,204 |
| 0.00,205 |
| 0.00,206 |
+----------+
107 rows in set (0.00 sec)
```

## 条件查询

### 语法

```mysql
SELECT 查询列表 FROM 表名 WHERE 筛选条件;
```

### 分类

#### 按条件表达式筛选

条件运算符：  >  <  =  <>(!=)  >=  <=  <=>

#### 按逻辑表达式查询

逻辑运算符：  and(&&)  or(||)  not(!)

#### 模糊查询

- like
- between and
- in 
- is null/is not null

##### 特点

一般和通配符搭配使用

| 通配符 | 意义         |
| ------ | ------------ |
| %      | 任意多个字符 |
| _      | 任意单个字符 |

匹配通配符可用`\`转义，或者通过`ESCAPE`关键字转义，如`LIKE '_$_%' ESCAPE '$'`

### 演示

#### 条件运算符

```mysql
SELECT first_name,department_id FROM employees WHERE department_id<>90 ORDER BY department_id;
```

```
+-------------+---------------+
| first_name  | department_id |
+-------------+---------------+
| Jennifer    |            10 |
| Michael     |            20 |
| Pat         |            20 |
| Den         |            30 |
			......
| Ismael      |           100 |
| Jose Manuel |           100 |
| Luis        |           100 |
| Shelley     |           110 |
| William     |           110 |
+-------------+---------------+
103 rows in set (0.00 sec)
```

#### 逻辑运算符

```mysql
SELECT employee_id,first_name,salary FROM employees WHERE salary>=10000 AND salary<=20000;
```

```
+-------------+------------+----------+
| employee_id | first_name | salary   |
+-------------+------------+----------+
|         101 | Neena      | 17000.00 |
|         102 | Lex        | 17000.00 |
|         108 | Nancy      | 12000.00 |
|         114 | Den        | 11000.00 |
|         145 | John       | 14000.00 |
|         146 | Karen      | 13500.00 |
|         147 | Alberto    | 12000.00 |
|         148 | Gerald     | 11000.00 |
|         149 | Eleni      | 10500.00 |
|         150 | Peter      | 10000.00 |
|         156 | Janette    | 10000.00 |
|         162 | Clara      | 10500.00 |
|         168 | Lisa       | 11500.00 |
|         169 | Harrison   | 10000.00 |
|         174 | Ellen      | 11000.00 |
|         201 | Michael    | 13000.00 |
|         204 | Hermann    | 10000.00 |
|         205 | Shelley    | 12000.00 |
+-------------+------------+----------+
18 rows in set (0.00 sec)
```

#### 模糊查询

##### LIKE

```mysql
SELECT employee_id,first_name FROM employees WHERE first_name LIKE '%a%';
```

```
+-------------+-------------+
| employee_id | first_name  |
+-------------+-------------+
|         101 | Neena       |
|         103 | Alexander   |
|         105 | David       |
			......
|         202 | Pat         |
|         203 | Susan       |
|         204 | Hermann     |
|         206 | William     |
+-------------+-------------+
70 rows in set (0.00 sec)
```

```mysql
SELECT employee_id,first_name,salary FROM employees WHERE first_name LIKE '__e_a%';
```

```
+-------------+------------+----------+
| employee_id | first_name | salary   |
+-------------+------------+----------+
|         101 | Neena      | 17000.00 |
|         103 | Alexander  |  9000.00 |
|         115 | Alexander  |  3100.00 |
+-------------+------------+----------+
3 rows in set (0.00 sec)
```

```mysql
SELECT employee_id,first_name,last_name,salary FROM employees WHERE last_name LIKE '_\_%';
```

或者

```mysql
SELECT employee_id,first_name,last_name,salary FROM employees WHERE last_name LIKE '_$_%' ESCAPE '$';
```

```
+-------------+------------+-----------+----------+
| employee_id | first_name | last_name | salary   |
+-------------+------------+-----------+----------+
|         100 | Steven     | K_ing     | 24000.00 |
|         156 | Janette    | K_ing     | 10000.00 |
+-------------+------------+-----------+----------+
2 rows in set (0.00 sec)
```

##### BETWEEN AND

```mysql
SELECT employee_id,first_name,last_name,salary FROM employees WHERE employee_id BETWEEN 100 AND 120;
```

```
+-------------+-------------+------------+----------+
| employee_id | first_name  | last_name  | salary   |
+-------------+-------------+------------+----------+
|         100 | Steven      | K_ing      | 24000.00 |
|         101 | Neena       | Kochhar    | 17000.00 |
						......
|         119 | Karen       | Colmenares |  2500.00 |
|         120 | Matthew     | Weiss      |  8000.00 |
+-------------+-------------+------------+----------+
21 rows in set (0.00 sec)
```

##### IN

```mysql
SELECT employee_id,first_name,last_name,job_id FROM employees WHERE job_id IN('IT_PROG','AD_VP','AD_PRES');
```

```
+-------------+------------+-----------+---------+
| employee_id | first_name | last_name | job_id  |
+-------------+------------+-----------+---------+
|         100 | Steven     | K_ing     | AD_PRES |
|         101 | Neena      | Kochhar   | AD_VP   |
|         102 | Lex        | De Haan   | AD_VP   |
|         103 | Alexander  | Hunold    | IT_PROG |
|         104 | Bruce      | Ernst     | IT_PROG |
|         105 | David      | Austin    | IT_PROG |
|         106 | Valli      | Pataballa | IT_PROG |
|         107 | Diana      | Lorentz   | IT_PROG |
+-------------+------------+-----------+---------+
8 rows in set (0.00 sec)
```

##### IS NULL/IS NOT NULL

```mysql
SELECT employee_id,first_name,last_name,commission_pct FROM employees WHERE commission_pct IS NULL;
```

```
+-------------+-------------+-------------+----------------+
| employee_id | first_name  | last_name   | commission_pct |
+-------------+-------------+-------------+----------------+
|         100 | Steven      | K_ing       |           NULL |
|         101 | Neena       | Kochhar     |           NULL |
						......
|         205 | Shelley     | Higgins     |           NULL |
|         206 | William     | Gietz       |           NULL |
+-------------+-------------+-------------+----------------+
72 rows in set (0.00 sec)
```

```mysql
SELECT employee_id,first_name,last_name,commission_pct FROM employees WHERE commission_pct IS NOT NULL;
```

```
+-------------+-------------+------------+----------------+
| employee_id | first_name  | last_name  | commission_pct |
+-------------+-------------+------------+----------------+
|         145 | John        | Russell    |           0.40 |
|         146 | Karen       | Partners   |           0.30 |
						......
|         178 | Kimberely   | Grant      |           0.15 |
|         179 | Charles     | Johnson    |           0.10 |
+-------------+-------------+------------+----------------+
35 rows in set (0.00 sec)
```

#### 安全等于

```mysql
SELECT employee_id,first_name,last_name,commission_pct FROM employees WHERE commission_pct <=> NULL;
```

```
+-------------+-------------+-------------+----------------+
| employee_id | first_name  | last_name   | commission_pct |
+-------------+-------------+-------------+----------------+
|         100 | Steven      | K_ing       |           NULL |
|         101 | Neena       | Kochhar     |           NULL |
						......
|         206 | William     | Gietz       |           NULL |
+-------------+-------------+-------------+----------------+
72 rows in set (0.00 sec)
```

## 排序查询

### 语法

```mysql
SELECT 字段 FROM 表名 (WHERE 筛选条件) ORDER BY 排序字段 (ASC/DESC);
```

`ASC`为升序，`DESC`为降序，默认为升序

### 演示

```mysql
SELECT employee_id,first_name,last_name,hiredate FROM employees WHERE department_id>=90 ORDER BY hiredate;
```

```
+-------------+-------------+-----------+---------------------+
| employee_id | first_name  | last_name | hiredate            |
+-------------+-------------+-----------+---------------------+
|         100 | Steven      | K_ing     | 1992-04-03 00:00:00 |
|         101 | Neena       | Kochhar   | 1992-04-03 00:00:00 |
|         102 | Lex         | De Haan   | 1992-04-03 00:00:00 |
|         108 | Nancy       | Greenberg | 1998-03-03 00:00:00 |
|         109 | Daniel      | Faviet    | 1998-03-03 00:00:00 |
|         110 | John        | Chen      | 2000-09-09 00:00:00 |
|         111 | Ismael      | Sciarra   | 2000-09-09 00:00:00 |
|         112 | Jose Manuel | Urman     | 2000-09-09 00:00:00 |
|         113 | Luis        | Popp      | 2000-09-09 00:00:00 |
|         205 | Shelley     | Higgins   | 2016-03-03 00:00:00 |
|         206 | William     | Gietz     | 2016-03-03 00:00:00 |
+-------------+-------------+-----------+---------------------+
11 rows in set (0.00 sec)
```

```mysql
SELECT employee_id,first_name,last_name,salary*12*(1+IFNULL(commission_pct,0)) AS 'annual salary' FROM employees ORDER BY salary*12*(1+IFNULL(commission_pct,0));
```

```
+-------------+-------------+-------------+---------------+
| employee_id | first_name  | last_name   | annual salary |
+-------------+-------------+-------------+---------------+
|         132 | TJ          | Olson       |      25200.00 |
|         128 | Steven      | Markle      |      26400.00 |
						......
|         145 | John        | Russell     |     235200.00 |
|         100 | Steven      | K_ing       |     288000.00 |
+-------------+-------------+-------------+---------------+
107 rows in set (0.00 sec)
```

```mysql
SELECT employee_id,first_name,last_name,salary*12*(1+IFNULL(commission_pct,0)) AS 'annual salary' FROM employees ORDER BY `annual salary`;
```

```
+-------------+-------------+-------------+---------------+
| employee_id | first_name  | last_name   | annual salary |
+-------------+-------------+-------------+---------------+
|         132 | TJ          | Olson       |      25200.00 |
|         128 | Steven      | Markle      |      26400.00 |
						......
|         145 | John        | Russell     |     235200.00 |
|         100 | Steven      | K_ing       |     288000.00 |
+-------------+-------------+-------------+---------------+
107 rows in set (0.00 sec)
```

此处使用单引号包裹不生效

```mysql
SELECT employee_id,first_name,last_name,LENGTH(first_name) AS 名字长度 FROM employees ORDER BY 名字长度;
```

```
+-------------+-------------+-------------+----------+
| employee_id | first_name  | last_name   | 名字长度  |
+-------------+-------------+-------------+----------+
|         132 | TJ          | Olson       |        2 |
|         135 | Ki          | Gee         |        2 |
						......
|         153 | Christopher | Olsen       |       11 |
+-------------+-------------+-------------+----------+
107 rows in set (0.00 sec)
```

```mysql
SELECT employee_id,first_name,last_name,salary FROM employees ORDER BY salary ASC,employee_id DESC;
```

```
+-------------+-------------+-------------+----------+
| employee_id | first_name  | last_name   | salary   |
+-------------+-------------+-------------+----------+
|         132 | TJ          | Olson       |  2100.00 |
|         136 | Hazel       | Philtanker  |  2200.00 |
						......
|         100 | Steven      | K_ing       | 24000.00 |
+-------------+-------------+-------------+----------+
107 rows in set (0.00 sec)
```

## 常用函数

### 单行函数

#### 字符函数

##### length

LENGTH(str)，用于获取字符串字节长度，如utf-8下一个汉字的长度为3

##### concat

CONCAT(str1,str2,...)，用于拼接字符串

##### upper

UPPER(str)，将字母转换为大写

##### lower

LOWER(str)，将字母转换为小写

##### substr/substring

- SUBSTR/SUBSTRING(str FROM pos FOR len)
- SUBSTR/SUBSTRING(str FROM pos)
- SUBSTR/SUBSTRING(str,pos)
- SUBSTR/SUBSTRING(str,pos,len)

截取字符串，**索引从1开始**

##### instr

INSTR(str,substr)，返回在字符串中的索引，找不到则返回0

##### trim

- TRIM([remstr FROM] str)
- TRIM([{BOTH|LEADING|TRAILING} [remstr] FROM] str)

去除两侧的空格，使用`remstr`可指定去掉前后的指定字符

```mysql
SELECT TRIM("a" FROM "aaaaaaaaaaaaaaa12344aaaa5314aaaaaaaaa") AS output;
```

```
+---------------+
| output        |
+---------------+
| 12344aaaa5314 |
+---------------+
1 row in set (0.00 sec)
```

使用`BOTH|LEADING|TRAILING`关键字可指定去除头部尾部还是全部

```mysql
SELECT TRIM(LEADING "a" FROM "aaaaaaaaaaaaaaa12344aaaa5314aaaaaaaaa") AS output;
```

```
+------------------------+
| output                 |
+------------------------+
| 12344aaaa5314aaaaaaaaa |
+------------------------+
1 row in set (0.00 sec)
```

##### lpad/rpad

L/RPAD(str,len,padstr)，用指定的字符在左/右侧填充实现填充至指定长度

```mysql
SELECT LPAD("山东大学（威海）",20,"_") AS output,LENGTH(LPAD("山东大学（威海）",20,"_")) AS length;
```

```
+------------------------------+--------+
| output                       | length |
+------------------------------+--------+
| ____________山东大学（威海） |     28 |
+------------------------------+--------+
1 row in set (0.00 sec)
```

若长度超出则在右边截断

```mysql
SELECT LPAD("山东大学（威海）",5,"_") AS output,LENGTH(LPAD("山东大学（威海）",5,"_")) AS length;
```

```
+------------+--------+
| output     | length |
+------------+--------+
| 山东大学（ |     10 |
+------------+--------+
1 row in set (0.00 sec)
```

##### replace

REPLACE(str,from_str,to_str)，替换字符串中的内容

```mysql
SELECT REPLACE("山东大学威海分校","威海分校","（威海）") AS output;
```

```
+------------------+
| output           |
+------------------+
| 山东大学（威海） |
+------------------+
1 row in set (0.00 sec)
```



#### 数学函数

##### round

- ROUND(X)
- ROUND(X,D)

参数D为保留小数点后几位

```mysql
SELECT ROUND(1.6789,2) AS result;
```

```
+--------+
| result |
+--------+
|   1.68 |
+--------+
1 row in set (0.00 sec)
```

##### ceil/ceiling

CEIL/CEILING(X)，向上取整

```mysql
SELECT CEIL(1.675) AS result;
```

```
+--------+
| result |
+--------+
|      2 |
+--------+
1 row in set (0.00 sec)
```

##### floor

FLOOR(X)，

```mysql
SELECT FLOOR(2.13) AS result;
```

```
+--------+
| result |
+--------+
|      2 |
+--------+
1 row in set (0.00 sec)
```

##### truncate

TRUNCATE(X,D)，从第D位小数截断

```mysql
SELECT TRUNCATE(1.632589,4) AS result;
```

```
+--------+
| result |
+--------+
| 1.6325 |
+--------+
1 row in set (0.00 sec)
```

##### mod

MOD(N,M)，取余，与`%`的作用一致，使用`a-a/b*b`规则进行计算

```mysql
SELECT MOD(10,3) AS result;
```

```
+--------+
| result |
+--------+
|      1 |
+--------+
1 row in set (0.00 sec)
```

#### 日期函数

##### now

NOW()，返回当前系统日期+时间，等同于CURRENT_TIMESTAMP常量

```mysql
SELECT NOW();
```

```
+---------------------+
| NOW()               |
+---------------------+
| 2021-03-24 19:40:24 |
+---------------------+
1 row in set (0.00 sec)
```

##### curdate

CURDATE()，返回当前系统日期，不包括时间，等同于CURRENT_DATE常量

```mysql
SELECT CURDATE();
```

```
+------------+
| CURDATE()  |
+------------+
| 2021-03-24 |
+------------+
1 row in set (0.00 sec)
```

##### curtime

CURTIME()，返回当前系统时间，不包括日期，等同于CURRENT_TIME常量

```mysql
SELECT CURTIME();
```

```
+-----------+
| CURTIME() |
+-----------+
| 19:45:01  |
+-----------+
1 row in set (0.00 sec)
```

##### year

YEAR(date)，用于获取传入日期中的年份

```mysql
SELECT YEAR(NOW()) 年;
```

```
+------+
| 年   |
+------+
| 2021 |
+------+
1 row in set (0.00 sec)
```

##### month

MONTH(date)，用于获取传入日期中的月份

```mysql
SELECT MONTH(NOW()) 月;
```

```
+------+
| 月   |
+------+
|    3 |
+------+
1 row in set (0.00 sec)
```

##### monthname

MONTHNAME(date)，用于获取传入日期中的月份的名称

```mysql
SELECT MONTHNAME(NOW()) 月;
```

```
+-------+
| 月    |
+-------+
| March |
+-------+
1 row in set (0.00 sec)
```

##### hour

类上

##### minute

类上

##### second

类上

##### str_to_date

STR_TO_DATE(str,format)，将字符串类型的时间转换为指定格式的时间

```mysql
SELECT STR_TO_DATE("3-2021-24","%m-%Y-%d");
```

```
+-------------------------------------+
| STR_TO_DATE("3-2021-24","%m-%Y-%d") |
+-------------------------------------+
| 2021-03-24                          |
+-------------------------------------+
1 row in set (0.00 sec)
```

##### date_format

DATE_FORMAT(date,format)，将日期转换为字符

```mysql
SELECT DATE_FORMAT("2021/3/24","%Y年%m月%d月") 日期;
```

```
+----------------+
| 日期           |
+----------------+
| 2021年03月24月 |
+----------------+
1 row in set (0.00 sec)
```

| 格式符 | 功能             |
| ------ | ---------------- |
| %Y     | 四位的年份       |
| %y     | 两位的年份       |
| %m     | 月份（两位）     |
| %c     | 月份             |
| %d     | 日（两位）       |
| %H     | 小时（24小时制） |
| %h     | 小时（12小时制） |
| %i     | 分钟（两位）     |
| %s     | 秒（两位）       |

```mysql
SELECT DATE_FORMAT(hiredate,"%Y年%m月%d月 %d日%i分%s秒") 日期 FROM employees;
```

```
+-----------------------------+
| 日期                        |
+-----------------------------+
| 1992年04月03月 03日00分00秒 |
| 1992年04月03月 03日00分00秒 |
			......
| 2016年03月03月 03日00分00秒 |
| 2016年03月03月 03日00分00秒 |
+-----------------------------+
107 rows in set (0.00 sec)
```

##### datediff

DATEDIFF(expr1,expr2)

```mysql
SELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) AS day FROM employees;
```

```
+------+
| day  |
+------+
| 8735 |
+------+
1 row in set (0.00 sec)
```

#### 其他函数（补充）

VERSION()

DATABASE()

USER()

#### 流程控制函数（补充）

##### if

IF(expr1,expr2,expr3)

```mysql
SELECT first_name,commission_pct,IF(commission_pct IS NULL,"没有奖金","有奖金") AS 备注 FROM employees ORDER BY commission_pct;
```

```
+-------------+----------------+----------+
| first_name  | commission_pct | 备注     |
+-------------+----------------+----------+
| Steven      |           NULL | 没有奖金 |
| Neena       |           NULL | 没有奖金 |
					......
| Allan       |           0.35 | 有奖金   |
| John        |           0.40 | 有奖金   |
+-------------+----------------+----------+
107 rows in set (0.00 sec)
```

##### case

```mysql
CASE case_value
	WHEN when_value THEN
		statement_list
	ELSE
		statement_list
END CASE;
```

###### 用法一

```mysql
SELECT salary 原始工资, department_id, CASE department_id
	WHEN 30 THEN
		salary*1.1
	WHEN 40 THEN
		salary*1.2
	WHEN 50 THEN
		salary*1.3
	ELSE
		salary
END AS 新工资 FROM employees ORDER BY 新工资;
```

```
+----------+---------------+----------+
| 原始工资 | department_id | 新工资   |
+----------+---------------+----------+
|  2100.00 |            50 |  2730.00 |
|  2500.00 |            30 |  2750.00 |
				......
| 17000.00 |            90 | 17000.00 |
| 24000.00 |            90 | 24000.00 |
+----------+---------------+----------+
107 rows in set (0.00 sec)
```

###### 用法二

```mysql
SELECT first_name, CASE 
	WHEN salary<10001 THEN
		"初等职工"
	WHEN salary<20001 AND salary>10000 THEN
	  "中等职工"
	WHEN salary>20000 THEN
	  "高等职工"
	ELSE
		""
END AS 职工等级 FROM employees ORDER BY salary;
```

```
+-------------+----------+
| first_name  | 职工等级 |
+-------------+----------+
| TJ          | 初等职工 |
| Steven      | 初等职工 |
		......
| Neena       | 中等职工 |
| Lex         | 中等职工 |
| Steven      | 高等职工 |
+-------------+----------+
107 rows in set (0.00 sec)
```



### 分组函数

也叫统计函数、聚合函数、多行函数、组函数，用作统计使用

#### sum

SUM([DISTINCT] expr)，求和

#### avg

AVG([DISTINCT] expr)，求平均值

#### max

MAX([DISTINCT] expr)，求最大值

#### min

MIN([DISTINCT] expr)，求最小值

#### count

COUNT([DISTINCT] expr[,expr...])，计数

##### 详细介绍

可以用来统计行数

```mysql
SELECT COUNT(*) FROM employees;
```

```
+----------+
| COUNT(*) |
+----------+
|      107 |
+----------+
1 row in set (0.00 sec)
```

统计不全为NULL的行

```mysql
SELECT COUNT(1) FROM employees;
```

```
+----------+
| COUNT(1) |
+----------+
|      107 |
+----------+
1 row in set (0.00 sec)
```

相当于新建一行，全部填充1，进行统计，使用别的值也可以（除了NULL）

###### 效率

MYISAM引擎下，COUNT(\*)的效率最高；INNODB引擎下，COUNT(\*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些，一般用COUNT(\*)

#### 特点

- `sum` `avg` 一般用于处理数值型，`max` `min` `count`可以处理任何类型
- 都忽略NULL值
- 可以和`DISTINCT`搭配进行去重操作
- 和分组函数一同查询的字段要求是GROUP BY后的字段

## 分组查询

### 简单使用

```mysql
SELECT AVG(salary),department_id FROM employees GROUP BY department_id;
```

```
+--------------+---------------+
| AVG(salary)  | department_id |
+--------------+---------------+
|  7000.000000 |          NULL |
|  4400.000000 |            10 |
|  9500.000000 |            20 |
|  4150.000000 |            30 |
|  6500.000000 |            40 |
|  3475.555556 |            50 |
|  5760.000000 |            60 |
| 10000.000000 |            70 |
|  8955.882353 |            80 |
| 19333.333333 |            90 |
|  8600.000000 |           100 |
| 10150.000000 |           110 |
+--------------+---------------+
12 rows in set (0.00 sec)
```

```mysql
SELECT MAX(salary),job_id FROM employees GROUP BY job_id;
```

```
+-------------+------------+
| MAX(salary) | job_id     |
+-------------+------------+
|     8300.00 | AC_ACCOUNT |
|    12000.00 | AC_MGR     |
|     4400.00 | AD_ASST    |
|    24000.00 | AD_PRES    |
|    17000.00 | AD_VP      |
|     9000.00 | FI_ACCOUNT |
|    12000.00 | FI_MGR     |
|     6500.00 | HR_REP     |
|     9000.00 | IT_PROG    |
|    13000.00 | MK_MAN     |
|     6000.00 | MK_REP     |
|    10000.00 | PR_REP     |
|     3100.00 | PU_CLERK   |
|    11000.00 | PU_MAN     |
|    14000.00 | SA_MAN     |
|    11500.00 | SA_REP     |
|     4200.00 | SH_CLERK   |
|     3600.00 | ST_CLERK   |
|     8200.00 | ST_MAN     |
+-------------+------------+
19 rows in set (0.00 sec)
```

```mysql
SELECT COUNT(*),location_id FROM departments GROUP BY location_id;
```

```
+----------+-------------+
| COUNT(*) | location_id |
+----------+-------------+
|        1 |        1400 |
|        1 |        1500 |
|       21 |        1700 |
|        1 |        1800 |
|        1 |        2400 |
|        1 |        2500 |
|        1 |        2700 |
+----------+-------------+
7 rows in set (0.00 sec)
```

### 添加分组前筛选

```mysql
SELECT AVG(salary),department_id FROM employees WHERE email LIKE '%a%' GROUP BY department_id;
```

```
+--------------+---------------+
| AVG(salary)  | department_id |
+--------------+---------------+
|  7000.000000 |          NULL |
|  4400.000000 |            10 |
|  9500.000000 |            20 |
|  4460.000000 |            30 |
|  6500.000000 |            40 |
|  3496.153846 |            50 |
|  6200.000000 |            60 |
| 10000.000000 |            70 |
|  8535.294118 |            80 |
| 17000.000000 |            90 |
|  8166.666667 |           100 |
+--------------+---------------+
11 rows in set (0.00 sec)
```

```mysql
SELECT MAX(salary),manager_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY manager_id;
```

```
+-------------+------------+
| MAX(salary) | manager_id |
+-------------+------------+
|    14000.00 |        100 |
|    10000.00 |        145 |
|    10000.00 |        146 |
|    10500.00 |        147 |
|    11500.00 |        148 |
|    11000.00 |        149 |
+-------------+------------+
6 rows in set (0.00 sec)
```

### 添加分组后筛选

```mysql
SELECT COUNT(*),department_id FROM employees GROUP BY department_id HAVING COUNT(*)>2;
```

```
+----------+---------------+
| COUNT(*) | department_id |
+----------+---------------+
|        6 |            30 |
|       45 |            50 |
|        5 |            60 |
|       34 |            80 |
|        3 |            90 |
|        6 |           100 |
+----------+---------------+
6 rows in set (0.00 sec)
```

```mysql
SELECT job_id,MAX(salary) FROM employees WHERE commission_pct IS NOT NULL GROUP BY job_id HAVING MAX(salary)>12000;
```

```
+--------+-------------+
| job_id | MAX(salary) |
+--------+-------------+
| SA_MAN |    14000.00 |
+--------+-------------+
1 row in set (0.00 sec)
```

```mysql
SELECT MIN(salary),manager_id FROM employees WHERE manager_id>102 GROUP BY manager_id HAVING MIN(salary)>5000;
```

```
+-------------+------------+
| MIN(salary) | manager_id |
+-------------+------------+
|     6900.00 |        108 |
|     7000.00 |        145 |
|     7000.00 |        146 |
|     6200.00 |        147 |
|     6100.00 |        148 |
|     6200.00 |        149 |
|     6000.00 |        201 |
|     8300.00 |        205 |
+-------------+------------+
8 rows in set (0.00 sec)
```

### 按表达式或函数分组

```mysql
SELECT COUNT(*),LENGTH(first_name) FROM employees GROUP BY LENGTH(first_name) HAVING COUNT(*)>5 ORDER BY LENGTH(first_name);
```

```
+----------+--------------------+
| COUNT(*) | LENGTH(first_name) |
+----------+--------------------+
|        9 |                  4 |
|       35 |                  5 |
|       23 |                  6 |
|       23 |                  7 |
+----------+--------------------+
4 rows in set (0.00 sec)
```

可用别名简化为

```mysql
SELECT COUNT(*) c,LENGTH(first_name) FROM employees GROUP BY LENGTH(first_name) HAVING c>5 ORDER BY LENGTH(first_name);
```

### 按多个字段分组

```mysql
SELECT AVG(salary),department_id,job_id FROM employees GROUP BY department_id,job_id ORDER BY department_id;
```

```
+--------------+---------------+------------+
| AVG(salary)  | department_id | job_id     |
+--------------+---------------+------------+
|  7000.000000 |          NULL | SA_REP     |
|  4400.000000 |            10 | AD_ASST    |
| 13000.000000 |            20 | MK_MAN     |
|  6000.000000 |            20 | MK_REP     |
|  2780.000000 |            30 | PU_CLERK   |
| 11000.000000 |            30 | PU_MAN     |
|  6500.000000 |            40 | HR_REP     |
|  3215.000000 |            50 | SH_CLERK   |
|  2785.000000 |            50 | ST_CLERK   |
|  7280.000000 |            50 | ST_MAN     |
|  5760.000000 |            60 | IT_PROG    |
| 10000.000000 |            70 | PR_REP     |
| 12200.000000 |            80 | SA_MAN     |
|  8396.551724 |            80 | SA_REP     |
| 24000.000000 |            90 | AD_PRES    |
| 17000.000000 |            90 | AD_VP      |
|  7920.000000 |           100 | FI_ACCOUNT |
| 12000.000000 |           100 | FI_MGR     |
|  8300.000000 |           110 | AC_ACCOUNT |
| 12000.000000 |           110 | AC_MGR     |
+--------------+---------------+------------+
20 rows in set (0.00 sec)
```

只有`department_id`和`job_id`相同时才为一行

## 连接查询

又称为多表查询，当查询的字段来自于多个表时，就会用到多表查询

### 笛卡尔乘积现象

表1有x行，表2有y行，结果为x*y行

```mysql
SELECT `name`,boyName FROM boys,beauty;
```

```
+------------+---------+
| name       | boyName |
+------------+---------+
| 柳岩       | 张无忌  |
| 柳岩       | 鹿晗    |
| 柳岩       | 黄晓明  |
| 柳岩       | 段誉    |
| 苍老师     | 张无忌  |
| 苍老师     | 鹿晗    |
		......
| 夏雪       | 段誉    |
| 赵敏       | 张无忌  |
| 赵敏       | 鹿晗    |
| 赵敏       | 黄晓明  |
| 赵敏       | 段誉    |
+------------+---------+
48 rows in set (0.00 sec)
```

这样做相当于把`beauty`表中的每一行与`boys`表中的每一行进行匹配，称为笛卡尔乘积现象，最终实现所有行全连接，要避免的话必须加上有效的连接条件

加上连接条件后

```mysql
SELECT `name`,boyName FROM beauty,boys WHERE boyfriend_id=id;
```

```
ERROR 1052 (23000): Column 'id' in where clause is ambiguous
```

因为`boys`和`beauty`中都有id，id不明确，所以要加上表名

```mysql
SELECT `name`,boyName FROM beauty,boys WHERE boyfriend_id=boys.id;
```

```
+------------+---------+
| name       | boyName |
+------------+---------+
| Angelababy | 黄晓明  |
| 热巴       | 鹿晗    |
| 周芷若     | 张无忌  |
| 小昭       | 张无忌  |
| 王语嫣     | 段誉    |
| 赵敏       | 张无忌  |
+------------+---------+
6 rows in set (0.00 sec)
```

### 分类

#### 按年代分

##### sql92标准

支持内连接和部分外连接，MySQL中不支持外连接

##### sql99标准（推荐）

MySQL中支持内连接+外连接（左外连接、右外连接）+交叉连接

#### 按功能分

##### 内连接

等值连接

非等值连接

自连接

##### 外连接

左外连接

右外连接

全外连接

##### 交叉连接

### sql92标准

#### 内连接

##### 等值连接

###### 语法

```mysql
SELECT 字段1，字段2 FROM 表1，表2 WHERE 连接条件;
```

首先全连接，表1中的每一行都与表2中的每一行进行匹配，然后根据连接条件进行筛选，如果匹配则显示，如果不匹配则过滤掉

###### 示范

```mysql
SELECT first_name, department_name FROM employees,departments WHERE employees.department_id=departments.department_id;
```

```
+-------------+-----------------+
| first_name  | department_name |
+-------------+-----------------+
| Jennifer    | Adm             |
| Michael     | Mar             |
			......
| Shelley     | Acc             |
| William     | Acc             |
+-------------+-----------------+
106 rows in set (0.00 sec)
```

```mysql
SELECT first_name,employees.job_id,job_title FROM employees,jobs WHERE employees.job_id=jobs.job_id;
```

```
+-------------+------------+---------------------------------+
| first_name  | job_id     | job_title                       |
+-------------+------------+---------------------------------+
| William     | AC_ACCOUNT | Public Accountant               |
| Shelley     | AC_MGR     | Accounting Manager              |
| Jennifer    | AD_ASST    | Administration Assistant        |
					......
| Payam       | ST_MAN     | Stock Manager                   |
| Shanta      | ST_MAN     | Stock Manager                   |
| Kevin       | ST_MAN     | Stock Manager                   |
+-------------+------------+---------------------------------+
107 rows in set (0.00 sec)
```

数据库名称较长时可使用别名，起名方式与字段别名相同，起别名后不能使用原有数据库名称

```mysql
SELECT first_name,e.job_id,job_title FROM employees AS e,jobs AS j WHERE e.job_id=j.job_id;
```



```mysql
SELECT first_name,department_name FROM employees e,departments d WHERE e.commission_pct IS NOT NULL AND e.department_id=d.department_id;
```

```
+-------------+-----------------+
| first_name  | department_name |
+-------------+-----------------+
| John        | Sal             |
| Karen       | Sal             |
| Alberto     | Sal             |
			......
| Jack        | Sal             |
| Charles     | Sal             |
+-------------+-----------------+
34 rows in set (0.00 sec)
```

```mysql
SELECT department_name,city FROM departments d,locations l WHERE d.location_id=l.location_id AND city LIKE "_o%";
```

```
+-----------------+---------------------+
| department_name | city                |
+-----------------+---------------------+
| IT              | Southlake           |
| Shi             | South San Francisco |
| Mar             | Toronto             |
| Hum             | London              |
+-----------------+---------------------+
4 rows in set (0.00 sec)
```

```mysql
SELECT COUNT(*),city FROM departments d,locations l WHERE d.location_id=l.location_id GROUP BY city;
```

```
+----------+---------------------+
| COUNT(*) | city                |
+----------+---------------------+
|        1 | Southlake           |
|        1 | South San Francisco |
|       21 | Seattle             |
|        1 | Toronto             |
|        1 | London              |
|        1 | Oxford              |
|        1 | Munich              |
+----------+---------------------+
7 rows in set (0.00 sec)
```

```mysql
SELECT department_name,d.manager_id,MIN(salary) FROM departments d,employees e WHERE commission_pct IS NOT NULL AND d.department_id=e.department_id GROUP BY department_name;
```

```
+-----------------+------------+-------------+
| department_name | manager_id | MIN(salary) |
+-----------------+------------+-------------+
| Sal             |        145 |     6100.00 |
+-----------------+------------+-------------+
1 row in set (0.00 sec)
```

三表查询

```mysql
SELECT first_name,department_name,city FROM employees e,departments d,locations l WHERE e.department_id=d.department_id AND d.location_id=l.location_id;
```

```
+-------------+-----------------+---------------------+
| first_name  | department_name | city                |
+-------------+-----------------+---------------------+
| Jennifer    | Adm             | Seattle             |
| Michael     | Mar             | Toronto             |
					......
| Shelley     | Acc             | Seattle             |
| William     | Acc             | Seattle             |
+-------------+-----------------+---------------------+
106 rows in set (0.00 sec)
```

##### 非等值连接

```mysql
SELECT salary,grade_level FROM employees e,job_grades j WHERE salary BETWEEN lowest_sal AND highest_sal ORDER BY salary;
```

```
+----------+-------------+
| salary   | grade_level |
+----------+-------------+
|  2100.00 | A           |
|  2200.00 | A           |
|  2200.00 | A           |
		......
| 17000.00 | E           |
| 24000.00 | E           |
+----------+-------------+
107 rows in set (0.00 sec)
```

##### 自连接

利用别名对同一个表查询两次

```mysql
SELECT e.employee_id,e.first_name,m.employee_id,m.first_name FROM employees e,employees m WHERE e.manager_id=m.employee_id;
```

```
+-------------+-------------+-------------+------------+
| employee_id | first_name  | employee_id | first_name |
+-------------+-------------+-------------+------------+
|         101 | Neena       |         100 | Steven     |
|         102 | Lex         |         100 | Steven     |
						......
|         205 | Shelley     |         101 | Neena      |
|         206 | William     |         205 | Shelley    |
+-------------+-------------+-------------+------------+
106 rows in set (0.00 sec)
```

### sql99标准

#### 语法

```mysql
SELECT 查询列表 FROM 表1 别名 [连接类型] JOIN 表2 别名 ON 连接条件 [WHERE 筛选条件] [GROUP BY 分组] [HAVING 筛选条件] [ORDER BY 排序列表];
```

#### 连接类型

- 内连接	inner
- 外连接
  - 左外连接	left outer
  - 右外连接    right outer
  - 全外连接    full outer
- 交叉连接  cross

#### 内连接

##### 语法

```mysql
SELECT 查询列表 FROM 表1 别名 INNER JOIN 表2 别名 ON 连接条件;
```

##### 等值连接

基本查询

```mysql
SELECT first_name,department_name FROM employees e INNER JOIN departments d ON e.department_id=d.department_id;
```

```
+-------------+-----------------+
| first_name  | department_name |
+-------------+-----------------+
| Jennifer    | Adm             |
| Michael     | Mar             |
| Pat         | Mar             |
			......
| Jose Manuel | Fin             |
| Luis        | Fin             |
| Shelley     | Acc             |
| William     | Acc             |
+-------------+-----------------+
106 rows in set (0.00 sec)
```

加上筛选

```mysql
SELECT first_name,job_title FROM employees e INNER JOIN jobs j ON e.job_id=j.job_id WHERE first_name LIKE '%e%';
```

```
+-------------+---------------------------------+
| first_name  | job_title                       |
+-------------+---------------------------------+
| Steven      | President                       |
| Neena       | Administration Vice President   |
					......
| Jennifer    | Administration Assistant        |
| Michael     | Marketing Manager               |
| Hermann     | Public Relations Representative |
| Shelley     | Accounting Manager              |
+-------------+---------------------------------+
56 rows in set (0.00 sec)
```

加上分组

```mysql
SELECT COUNT(*),city FROM departments d INNER JOIN locations l ON d.location_id=l.location_id GROUP BY city HAVING COUNT(*)>3;
```

```
+----------+---------+
| COUNT(*) | city    |
+----------+---------+
|       21 | Seattle |
+----------+---------+
1 row in set (0.00 sec)
```

加上排序

```mysql
SELECT COUNT(*),department_name FROM departments d INNER JOIN employees e ON d.department_id=e.department_id GROUP BY d.department_id HAVING COUNT(*)>3 ORDER BY COUNT(*) DESC;
```

```
+----------+-----------------+
| COUNT(*) | department_name |
+----------+-----------------+
|       45 | Shi             |
|       34 | Sal             |
|        6 | Pur             |
|        6 | Fin             |
|        5 | IT              |
+----------+-----------------+
5 rows in set (0.00 sec)
```

##### 非等值连接

```mysql
SELECT first_name, grade_level 工资级别 FROM employees e INNER JOIN job_grades g ON salary BETWEEN lowest_sal AND highest_sal ORDER BY 工资级别;
```

```
+-------------+----------+
| first_name  | 工资级别 |
+-------------+----------+
| Shelli      | A        |
| Sigal       | A        |
| Guy         | A        |
			......
| Steven      | E        |
| Neena       | E        |
| Lex         | E        |
+-------------+----------+
107 rows in set (0.01 sec)
```

```mysql
SELECT COUNT(*), grade_level 工资级别 FROM employees e INNER JOIN job_grades g ON salary BETWEEN lowest_sal AND highest_sal GROUP BY 工资级别 ORDER BY 工资级别;
```

```
+----------+----------+
| COUNT(*) | 工资级别 |
+----------+----------+
|       24 | A        |
|       26 | B        |
|       38 | C        |
|       16 | D        |
|        3 | E        |
+----------+----------+
5 rows in set (0.00 sec)
```

##### 自连接

```mysql
SELECT e.employee_id,e.first_name,m.employee_id,m.first_name FROM employees e INNER JOIN employees m ON e.manager_id=m.employee_id;
```

```
+-------------+-------------+-------------+------------+
| employee_id | first_name  | employee_id | first_name |
+-------------+-------------+-------------+------------+
|         101 | Neena       |         100 | Steven     |
|         102 | Lex         |         100 | Steven     |
|         103 | Alexander   |         102 | Lex        |
						......
|         204 | Hermann     |         101 | Neena      |
|         205 | Shelley     |         101 | Neena      |
|         206 | William     |         205 | Shelley    |
+-------------+-------------+-------------+------------+
106 rows in set (0.00 sec)
```

#### 外连接

##### 应用场景

用于一个表中有，另一个表中没有的记录

##### 特点

- 外连接的查询结果为主表中的所有记录
  - 如果从表中有和它匹配的，则显示匹配的值
  - 如果从表中没有和它匹配的，则显示null
  - 外连接查询结果=内连接+主表中有而从表中没有的记录，即主表中能匹配上的直接显示，匹配不上的加上个null显示
- left join左边的是主表，right join右边的是主表
- 左外连接和右外连接可以交换顺序，实现同样的效果
- 全外连接=内连接+表1中有但表2没有+表2中有但表1没有

##### 演示

```mysql
SELECT b.`name`,bo.* FROM beauty b LEFT JOIN boys bo ON b.boyfriend_id=bo.id;
```

```
+------------+------+---------+--------+
| name       | id   | boyName | userCP |
+------------+------+---------+--------+
| 柳岩       | NULL | NULL    |   NULL |
| 苍老师     | NULL | NULL    |   NULL |
| Angelababy |    3 | 黄晓明  |     50 |
| 热巴       |    2 | 鹿晗    |    800 |
| 周冬雨     | NULL | NULL    |   NULL |
| 周芷若     |    1 | 张无忌  |    100 |
| 岳灵珊     | NULL | NULL    |   NULL |
| 小昭       |    1 | 张无忌  |    100 |
| 双儿       | NULL | NULL    |   NULL |
| 王语嫣     |    4 | 段誉    |    300 |
| 夏雪       | NULL | NULL    |   NULL |
| 赵敏       |    1 | 张无忌  |    100 |
+------------+------+---------+--------+
12 rows in set (0.00 sec)
```

加入筛选条件

```mysql
SELECT b.`name` FROM beauty b LEFT JOIN boys bo ON b.boyfriend_id=bo.id WHERE bo.id IS NULL;
```

```
+--------+
| name   |
+--------+
| 柳岩   |
| 苍老师 |
| 周冬雨 |
| 岳灵珊 |
| 双儿   |
| 夏雪   |
+--------+
6 rows in set (0.00 sec)
```

使用右外连接只需将关键字`LEFT JOIN`换成`RIGHT JOIN`并交换表的顺序即可



```mysql
SELECT d.department_name FROM departments d LEFT JOIN employees e ON d.department_id=e.department_id WHERE e.employee_id IS NULL;
```

```
+-----------------+
| department_name |
+-----------------+
| Tre             |
| Cor             |
| Con             |
| Sha             |
| Ben             |
| Man             |
| Con             |
| Con             |
| Ope             |
| IT              |
| NOC             |
| IT              |
| Gov             |
| Ret             |
| Rec             |
| Pay             |
+-----------------+
16 rows in set (0.00 sec)
```

##### 全外连接

全外连接=左外（右外）连接+反向左外（右外）

**此语法MySQL不支持**

```mysql
SELECT bo.*,b.* FROM boys bo FULL JOIN beauty b ON b.boyfriend_id=bo.id;
```

但是可以用`left(right) join union right(left)`来代替

```mysql
SELECT bo.*,b.* FROM boys bo LEFT JOIN beauty b ON b.boyfriend_id=bo.id UNION SELECT bo.*,b.* FROM boys bo RIGHT JOIN beauty b ON b.boyfriend_id=bo.id;
```

```
+------+---------+--------+------+------------+------+---------------------+-------------+--------------+--------------+
| id   | boyName | userCP | id   | name       | sex  | borndate            | phone       | photo        | boyfriend_id |
+------+---------+--------+------+------------+------+---------------------+-------------+--------------+--------------+
|    1 | 张无忌  |    100 |    6 | 周芷若     | 女   | 1988-02-03 00:00:00 | 18209876577 | 0x           |            1 |
|    1 | 张无忌  |    100 |    8 | 小昭       | 女   | 1989-02-03 00:00:00 | 18209876567 | 0x           |            1 |
|    1 | 张无忌  |    100 |   12 | 赵敏       | 女   | 1992-02-03 00:00:00 | 18209179577 | 0x           |            1 |
|    2 | 鹿晗    |    800 |    4 | 热巴       | 女   | 1993-02-03 00:00:00 | 18209876579 | 0x           |            2 |
|    3 | 黄晓明  |     50 |    3 | Angelababy | 女   | 1989-02-03 00:00:00 | 18209876567 | 0x           |            3 |
|    4 | 段誉    |    300 | NULL | NULL       | NULL | NULL                | NULL        | 0x           |         NULL |
| NULL | NULL    |   NULL |    1 | 柳岩       | 女   | 1988-02-03 00:00:00 | 18209876577 | 0x           |            8 |
| NULL | NULL    |   NULL |    2 | 苍老师     | 女   | 1987-12-30 00:00:00 | 18219876577 | 0x           |            9 |
| NULL | NULL    |   NULL |    5 | 周冬雨     | 女   | 1992-02-03 00:00:00 | 18209179577 | 0x           |            9 |
| NULL | NULL    |   NULL |    7 | 岳灵珊     | 女   | 1987-12-30 00:00:00 | 18219876577 | 0x           |            9 |
| NULL | NULL    |   NULL |    9 | 双儿       | 女   | 1993-02-03 00:00:00 | 18209876579 | 0x           |            9 |
| NULL | NULL    |   NULL |   10 | 王语嫣     | 女   | 1992-02-03 00:00:00 | 18209179577 | 0x           |         NULL |
| NULL | NULL    |   NULL |   11 | 夏雪       | 女   | 1993-02-03 00:00:00 | 18209876579 | 0x           |            9 |
+------+---------+--------+------+------------+------+---------------------+-------------+--------------+--------------+
13 rows in set (0.00 sec)
```

#### 交叉连接

```mysql
SELECT bo.*,b.* FROM boys bo CROSS JOIN beauty b;
```

```
+----+---------+--------+----+------------+------+---------------------+-------------+--------------+--------------+
| id | boyName | userCP | id | name       | sex  | borndate            | phone       | photo        | boyfriend_id |
+----+---------+--------+----+------------+------+---------------------+-------------+--------------+--------------+
|  1 | 张无忌  |    100 |  1 | 柳岩       | 女   | 1988-02-03 00:00:00 | 18209876577 | 0x           |            8 |
|  2 | 鹿晗    |    800 |  1 | 柳岩       | 女   | 1988-02-03 00:00:00 | 18209876577 | 0x           |            8 |
												......
|  3 | 黄晓明  |     50 | 12 | 赵敏       | 女   | 1992-02-03 00:00:00 | 18209179577 | 0x           |            1 |
|  4 | 段誉    |    300 | 12 | 赵敏       | 女   | 1992-02-03 00:00:00 | 18209179577 | 0x           |            1 |
+----+---------+--------+----+------------+------+---------------------+-------------+--------------+--------------+
48 rows in set (0.00 sec)
```

即使用sql99的语法实现笛卡尔乘积

#### 总结

![](https://github-yuzheng14.oss-cn-beijing.aliyuncs.com/MyNote/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/SQL/MySQL-%E5%B0%9A%E7%A1%85%E8%B0%B7/0cadea0db98ec91a5a5a0a806e8faec1.jfif)

## 子查询

以select为例

### 含义

出现在其它语句中的select语句，称为子查询，也叫内查询，外部的查询语句称为主查询或外查询

### 分类

#### 按子查询出现的位置

- select后面
  - 只支持标量子查询

- from后面
  - 支持表子查询

- **<font style="color:red">where或having后面</font>**
  - **<font style="color:red">标量子查询</font>**
  - **<font style="color:red">列子查询</font>**
  - 行子查询（用的较少）

- exists后面（相关子查询）
  - 表子查询

#### 按结果集的行列数不同

- 标量子查询（结果集只有一行一列）

- 列子查询（结果集只有一列多行）

- 行子查询（结果集有多行多列，主要是一行多列）

- 表子查询（结果集一般为多行多列）

### where或having后面

#### 特点

- 子查询放在小括号内
- 子查询一般放在条件的右侧
- 标量子查询一般搭配单行操作符使用
  - <  >  <=  >=  <>  =
- 列子查询，一般搭配多行操作符使用
  - IN    ANY/SOME    ALL
- 子查询执行优先于主查询

#### 标量子查询（单行子查询）

```mysql
SELECT employee_id,first_name,last_name,salary FROM employees WHERE salary>(SELECT salary FROM employees WHERE last_name='Abel');
```

```
+-------------+------------+-----------+----------+
| employee_id | first_name | last_name | salary   |
+-------------+------------+-----------+----------+
|         100 | Steven     | K_ing     | 24000.00 |
|         101 | Neena      | Kochhar   | 17000.00 |
|         102 | Lex        | De Haan   | 17000.00 |
|         108 | Nancy      | Greenberg | 12000.00 |
|         145 | John       | Russell   | 14000.00 |
|         146 | Karen      | Partners  | 13500.00 |
|         147 | Alberto    | Errazuriz | 12000.00 |
|         168 | Lisa       | Ozer      | 11500.00 |
|         201 | Michael    | Hartstein | 13000.00 |
|         205 | Shelley    | Higgins   | 12000.00 |
+-------------+------------+-----------+----------+
10 rows in set (0.00 sec)
```

```mysql
SELECT employee_id,first_name,job_id,salary FROM employees WHERE job_id=(
	SELECT job_id FROM employees WHERE employee_id=141
) AND salary>(
	SELECT salary FROM employees WHERE employee_id=143
);
```

```
+-------------+------------+----------+---------+
| employee_id | first_name | job_id   | salary  |
+-------------+------------+----------+---------+
|         125 | Julia      | ST_CLERK | 3200.00 |
|         126 | Irene      | ST_CLERK | 2700.00 |
|         129 | Laura      | ST_CLERK | 3300.00 |
|         130 | Mozhe      | ST_CLERK | 2800.00 |
|         133 | Jason      | ST_CLERK | 3300.00 |
|         134 | Michael    | ST_CLERK | 2900.00 |
|         137 | Renske     | ST_CLERK | 3600.00 |
|         138 | Stephen    | ST_CLERK | 3200.00 |
|         139 | John       | ST_CLERK | 2700.00 |
|         141 | Trenna     | ST_CLERK | 3500.00 |
|         142 | Curtis     | ST_CLERK | 3100.00 |
+-------------+------------+----------+---------+
11 rows in set (0.00 sec)
```

```mysql
SELECT employee_id,first_name,job_id,salary FROM employees WHERE salary=(
	SELECT MIN(salary) FROM employees
);
```

```
+-------------+------------+----------+---------+
| employee_id | first_name | job_id   | salary  |
+-------------+------------+----------+---------+
|         132 | TJ         | ST_CLERK | 2100.00 |
+-------------+------------+----------+---------+
1 row in set (0.00 sec)
```

```mysql
SELECT department_id,MIN(salary) FROM employees WHERE department_id IS NOT NULL GROUP BY department_id HAVING MIN(salary)>(
	SELECT MIN(salary) FROM employees WHERE department_id=50
);
```

```
+---------------+-------------+
| department_id | MIN(salary) |
+---------------+-------------+
|            10 |     4400.00 |
|            20 |     6000.00 |
|            30 |     2500.00 |
|            40 |     6500.00 |
|            60 |     4200.00 |
|            70 |    10000.00 |
|            80 |     6100.00 |
|            90 |    17000.00 |
|           100 |     6900.00 |
|           110 |     8300.00 |
+---------------+-------------+
10 rows in set (0.00 sec)
```

#### 列子查询（多行子查询）

```mysql
SELECT employee_id,first_name FROM employees WHERE department_id IN (
	SELECT department_id FROM departments WHERE location_id IN (1400,1700)
);
```

```
+-------------+-------------+
| employee_id | first_name  |
+-------------+-------------+
|         103 | Alexander   |
|         104 | Bruce       |
			......
|         205 | Shelley     |
|         206 | William     |
+-------------+-------------+
23 rows in set (0.00 sec)
```

此题也可用内连接方式解答

```mysql
SELECT employee_id,first_name FROM employees e INNER JOIN departments d ON e.department_id=d.department_id WHERE location_id=1400 IN (1400,1700);
```

```mysql
SELECT employee_id,first_name,job_id,salary FROM employees WHERE job_id<>'IT_PROG' AND salary<ANY(
	SELECT DISTINCT salary FROM employees WHERE job_id='IT_PROG'
);
```

```
+-------------+-------------+------------+---------+
| employee_id | first_name  | job_id     | salary  |
+-------------+-------------+------------+---------+
|         110 | John        | FI_ACCOUNT | 8200.00 |
|         111 | Ismael      | FI_ACCOUNT | 7700.00 |
						......
|         206 | William     | AC_ACCOUNT | 8300.00 |
+-------------+-------------+------------+---------+
76 rows in set (0.00 sec)
```

或者

```mysql
SELECT employee_id,first_name,job_id,salary FROM employees WHERE job_id<>'IT_PROG' AND salary<(
	SELECT DISTINCT MAX(salary) FROM employees WHERE job_id='IT_PROG'
);
```

#### 行子查询（多列多行）

```mysql
SELECT employee_id,first_name,salary FROM employees WHERE (employee_id,salary)=(
	SELECT MIN(employee_id),MAX(salary) FROM employees
);
```

```
+-------------+------------+----------+
| employee_id | first_name | salary   |
+-------------+------------+----------+
|         100 | Steven     | 24000.00 |
+-------------+------------+----------+
1 row in set (0.00 sec)
```

### select后面

